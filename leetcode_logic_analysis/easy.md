1. 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。示例1 [1, 2, 3, 4, 5]是。示例2 [0, 0, 1, 2, 5]是。 [扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)
   - 题干分析: 大小王是癞子，仅有的5张牌凑成顺子。
   - 解题逻辑: 
      1. 找出所有不是癞子的牌中最大的牌和最小的牌
      2. 判断不是癞子的牌有没有重复的牌
         - 如果有重复的牌就不是顺子
         - 如果没有重复的牌，就用最大牌减最小牌
            - ＜5就是顺子
            - 否则就不是顺子

2. n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。  示例1 [1,12,-5,-6,50,3], k = 4  最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 [子数组最大平均数](https://leetcode-cn.com/problems/maximum-average-subarray-i/)
   - 题干分析: 找到特定起点，长度为 k 的连续子数组。
   - 解题逻辑: 
     1. 首先对连续子数组的起点，进行从头到倒数第k个位置进行遍历，
     2. 起点在某一个位置时，计算sum和average，如果当前的average比之前的大，就记录当前连续子数组的起点位置索引值。

3. 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给定一个花坛（  表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。示例1 flowerbed = [1,0,0,0,1], n = 1  True        示例2 flowerbed = [1,0,0,0,1], n = 2   False  [种花](https://leetcode-cn.com/problemscan-place-flowers/)
   - 题干分析: 数组中1和1不能相邻。
   - 解题逻辑: 
     1. 遍历数组，如果数组中有一个 0，并且这个 0 的左右两侧都是 0，那么我们就可以在这个位置种花，即将这个位置的 0 修改成 1，总数count+1。
        - 对于数组的第一个和最后一个位置，我们只需要考虑一侧是否为 0。
     2. 最后count 与 n 进行比较，count >= n，那么返回 True，否则返回 False 。

4. 你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。 [排列硬币](https://leetcode-cn.com/problems/arranging-coins/)
```
   示例 1: n = 5  硬币可排列成以下几行:                       
   ¤                         
   ¤ ¤                       
   ¤ ¤
   因为第三行不完整，所以返回2.  
```
```
   示例 2: n = 8  硬币可排列成以下几行:               
   ¤
   ¤ ¤
   ¤ ¤ ¤
   ¤ ¤
   因为第四行不完整，所以返回3. 
```
   - 题干分析: n 是一个非负整数
   - 解题逻辑: 
     1. 设k记录硬币按题意排列的层数，初值为0.
     2. 当还余有硬币时，循环， 
```
         while(n >= 0)
         {
            k++;         //每层硬币递增一个，
            n = n - k;   //现有数目减去该层所需数目为余下硬币数目
         }
         return k - 1;   //最后输出需要硬币完整的层数
```

5. 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。示例 1： 输入：[4,2,1]  输出：4   解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。示例 2： 输入：[2,3,10] 输出：8   限制：1 <= n <= 4 ， 1 <= coins[i] <= 10   [拿硬币](https://leetcode-cn.com/problems/na-ying-bi/)
   - 题干分析: 有 n 堆硬币，每次从任意一堆拿走一枚或者两枚。问最少几次能够全部拿完。
   - 解题逻辑: 
     1. n堆硬币，每一堆都是要拿完的。而每一堆拿的情况又不影响其他硬币堆，因此每一堆硬币的拿法实际上是互相独立的。
     2. 硬币奇数的情况 sum = ((coins[i] + 1) / 2); 硬币偶数的情况 sum = (coins[i] / 2)  最后输出sum的奇偶和。

6. 有一个courses 表 ，有: student (学生) 和 class (课程).请列出所有超过或等于5名学生的课。 
   ```
      例如，表
      +---------+------------+
      | student | class      |
      +---------+------------+
      | A       | Math       |
      | B       | English    |
      | C       | Math       |
      | D       | Biology    |
      | E       | Math       |
      | F       | Computer   |
      | G       | Math       |
      | H       | Math       |
      | I       | Math       |
      +---------+------------+
   ```
   ```
      应该输出:
      +---------+
      | class   |
      +---------+
      | Math    |
      +---------+
   ```
   [超过5名学生的课](https://leetcode-cn.com/problems/classes-more-than-5-students/)
   - 题干分析: 找出被选次数超过或等于5次的课程。
   - 解题逻辑:
     1. 按照课程名称分组，首先统计选每门课的学生数量。
     2. 判断选课次数 >= 5

7. 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点.
   ```
   示例1:
      输入：[1, 2, 3, 3, 2, 1]
      输出：[1, 2, 3]
   ```
   ```
   示例2:
      输入：[1, 1, 1, 1, 2]
      输出：[1, 2]
   ```
   [移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)
   - 题干分析: 对链表做一次遍历，去除重复节点。
   - 解题逻辑: 
     1. 从head节点开始第一次循环链表。
     2. 第二重循环是判断head节点的下一个结点，到链表的末尾结束，将所有与保留节点相同的节点全部移除，使得前一个节点的next指向next.

8. 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
   示例: 输入: 38  输出: 2  解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 [各位相加](https://leetcode-cn.com/problems/add-digits/)
   - 题干分析: 反复将各个位上的数字相加，直到结果为一位数。
   - 解题逻辑:
     1. 判断num是否个位数
     2. 当num！=0时 sum = 0 循环 temp = num % 10; sum = sum + temp; num = num/10; 对num用%用来求余数，num除以10相当于丢掉个位，右移了一位。遍历判断当num等于0时，结果为余数之和。

9. 在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。返回重复了 N 次的那个元素。 
   示例 1：输入：[1,2,3,3] 输出：3  示例 2：输入：[2,1,2,5,3,2]  输出：2  示例 3：输入：[5,1,5,2,5,3,5,4] 输出：5 [重复 N 次的元素](https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/)
   - 题干分析: 2N长度的数组中有N+1个数，其中1个出现了N次,那么，剩下的N个数每个一定只出现1次。只要发现某个数出现了2次，它就是答案.
   - 解题逻辑: 
     1. 循环遍历数组查找相同的元素，从数组第一号元素开始和每一个元素进行对比.
     2. 设置2个参数a,b,遍历数组，for循环，从a 等于0开始，当a小于数组大小时，for循环，b等于a加1，当b小于数组大小时，判断数组的a号元素等于数组的b号元素相等时，该数就是重复的数，不相等时b加1，
        该for循环结束后，a加1进行上一个for循环。

10. 给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。
    示例 1: 输入: candies = [1,1,2,2,3,3] 输出: 3  一共有三种种类的糖果，每一种都有两个。最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。
    示例 2: 输入: candies = [1,1,2,3] 输出: 2  妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。[分糖果](https://leetcode-cn.com/problems/distribute-candies/)
    - 题干分析:找出妹妹可以获得的最多的糖果种类数
    - 解题逻辑:
      1. 遍历数组找出所有糖果种类，设置参数i,遍历数组，for循环，从i 等于1开始，当i小于数组大小时，判断数组的i号元素是否等于数组的i减1号元素，相等时，总数sum从0开始加1，i加1.
      2. 判断数组大小除以2是否大于糖果总类数，大于就返回数组的一半，小于就返回糖果总类数。

11. 如果数组是单调递增或单调递减的，那么它是单调的。如果对于所有 i <= j，A[i] <= A[j]，那么数组 A 是单调递增的。 如果对于所有 i <= j，A[i]> = A[j]，那么数组 A 是单调递减的。
    当给定的数组 A 是单调 数组时返回 true，否则返回 false。 示例 1：输入：[1,2,2,3] 输出：true  示例 2：输入：[6,5,4,4] 输出：true  示例 3：输入：[1,3,2] 输出：false  
    示例 4：输入：[1,2,4,5] 输出：true 示例 5：输入：[1,1,1] 输出：true [单调数列](https://leetcode-cn.com/problems/monotonic-array/)
    - 题干分析: 单调递增是下一号元素大于或等于上一号元素，单调递减是下一号元素小于或等于上一号元素。
    - 解题逻辑: 
      1. 首先判断数组0号元素大于最后一个元素时，遍历数组，判断上一个元素是否一直大于后一个元素，是就true 否就false
      2. 再判断数组0号元素小于最后一个元素时，遍历数组，判断上一个元素是否一直小于后一个元素，是就true 否就false
      3. 最后数组0号元素等于最后一个元素时，遍历数组，判断上一个元素是否一直等于后一个元素，是就true 否就false