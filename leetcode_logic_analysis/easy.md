1. 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。示例1 [1, 2, 3, 4, 5]是。示例2 [0, 0, 1, 2, 5]是。 [扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)
   - 题干分析: 大小王是癞子，仅有的5张牌凑成顺子。
   - 解题逻辑: 
      1. 找出所有不是癞子的牌中最大的牌和最小的牌
      2. 判断不是癞子的牌有没有重复的牌
         - 如果有重复的牌就不是顺子
         - 如果没有重复的牌，就用最大牌减最小牌
            - ＜5就是顺子
            - 否则就不是顺子

2. n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。  示例1 [1,12,-5,-6,50,3], k = 4  最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 [子数组最大平均数](https://leetcode-cn.com/problems/maximum-average-subarray-i/)
   - 题干分析: 找到特定起点，长度为 k 的连续子数组。
   - 解题逻辑: 
     1. 首先对连续子数组的起点，进行从头到倒数第k个位置进行遍历，
     2. 起点在某一个位置时，计算sum和average，如果当前的average比之前的大，就记录当前连续子数组的起点位置索引值。

3. 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给定一个花坛（  表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。示例1 flowerbed = [1,0,0,0,1], n = 1  True        示例2 flowerbed = [1,0,0,0,1], n = 2   False  [种花](https://leetcode-cn.com/problemscan-place-flowers/)
   - 题干分析: 数组中1和1不能相邻。
   - 解题逻辑: 
     1. 遍历数组，如果数组中有一个 0，并且这个 0 的左右两侧都是 0，那么我们就可以在这个位置种花，即将这个位置的 0 修改成 1，总数count+1。
        - 对于数组的第一个和最后一个位置，我们只需要考虑一侧是否为 0。
     2. 最后count 与 n 进行比较，count >= n，那么返回 True，否则返回 False 。

4. 你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。 [排列硬币](https://leetcode-cn.com/problems/arranging-coins/)
```
   示例 1: n = 5  硬币可排列成以下几行:                       
   ¤                         
   ¤ ¤                       
   ¤ ¤
   因为第三行不完整，所以返回2.  
```
```
   示例 2: n = 8  硬币可排列成以下几行:               
   ¤
   ¤ ¤
   ¤ ¤ ¤
   ¤ ¤
   因为第四行不完整，所以返回3. 
```
   - 题干分析: n 是一个非负整数
   - 解题逻辑: 
     1. 设k记录硬币按题意排列的层数，初值为0.
     2. 当还余有硬币时，循环， 
```
         while(n >= 0)
         {
            k++;         //每层硬币递增一个，
            n = n - k;   //现有数目减去该层所需数目为余下硬币数目
         }
         return k - 1;   //最后输出需要硬币完整的层数
```

5. 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。示例 1： 输入：[4,2,1]  输出：4   解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。示例 2： 输入：[2,3,10] 输出：8   限制：1 <= n <= 4 ， 1 <= coins[i] <= 10   [拿硬币](https://leetcode-cn.com/problems/na-ying-bi/)
   - 题干分析: 有 n 堆硬币，每次从任意一堆拿走一枚或者两枚。问最少几次能够全部拿完。
   - 解题逻辑: 
     1. n堆硬币，每一堆都是要拿完的。而每一堆拿的情况又不影响其他硬币堆，因此每一堆硬币的拿法实际上是互相独立的。
     2. 硬币奇数的情况 sum = ((coins[i] + 1) / 2); 硬币偶数的情况 sum = (coins[i] / 2)  最后输出sum的奇偶和。